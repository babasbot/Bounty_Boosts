
# Critical reentrancy vulnerability in executeRewardTranscaction function 

Submitted on Mar 22nd 2024 at 20:17:20 UTC by @Sadhunter for [Boost | Immunefi Arbitration](https://immunefi.com/bounty/immunefiarbitration-boost/)

Report ID: #29513

Report type: Smart Contract

Report severity: Insight

Target: https://github.com/immunefi-team/vaults/blob/main/src/RewardTimelock.sol

Impacts:
- Temporary freezing of funds
- Theft of gas
- Smart contract unable to operate due to lack of token funds
- Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield

## Description
## Brief/Intro
The vulnerability in the executeRewardTransaction function arises due to a potential reentrancy attack. In the current implementation, the contract updates the state of the transaction to TxState.Executed before executing an external call to immunefiModule.execute. This creates a window of opportunity for an attacker to exploit the reentrancy vulnerability.

## Vulnerability Details
Here's how the attack could occur:The attacker initiates a transaction to queue a reward transaction, passing malicious data.The contract processes the transaction and updates the state to TxState.Queued.Before the executeRewardTransaction function completes execution, the attacker re-enters the contract, invoking the same function.Since the contract's state has been updated to TxState.Executed, the attacker may manipulate the contract's state or perform unauthorized actions, potentially resulting in theft of funds or disruption of contract operations.The external call to immunefiModule.execute is executed, but the attacker may have already compromised the contract's state.

## Impact Details
The possible losses from exploiting the reentrancy vulnerability in the executeRewardTransaction function could be significant, primarily affecting user funds and the operational integrity of the smart contract. Here's a detailed breakdown of potential losses:Direct Theft of User Funds:An attacker could exploit the vulnerability to drain funds from the smart contract. This could include both the native tokens held by the contract as well as any ERC20 tokens it manages.The severity of this loss depends on the amount of funds stored in the contract at the time of the exploit. If substantial amounts of funds are at risk, the financial impact on users could be significant.Temporary Freezing of Funds:During the exploit, funds in the contract may become temporarily inaccessible to legitimate users. This could disrupt ongoing transactions and user activities, leading to frustration and loss of confidence in the platform.Theft of Gas:Reentrancy attacks often involve consuming excessive gas, which can lead to the theft of gas from users who interact with the vulnerable function. Users may incur financial losses due to wasted gas fees without receiving the expected service or benefit.Disruption of Contract Operations:If the attacker successfully drains a significant portion of the funds from the contract, it could render the contract unable to fulfill its intended operations. This could disrupt ongoing services, such as reward distributions or other critical functions, leading to user dissatisfaction and reputational damage.Overall, the potential losses from this exploit could be substantial, including direct financial losses for users, disruption of services, and damage to the platform's reputation. Given the severity of these potential impacts, immediate action to address and mitigate the vulnerability is essential to safeguard user funds and maintain the operational integrity of the smart contract.

## References
Add any relevant links to documentation or code



## Proof of Concept
// Hypothetical vulnerable contract with reentrancy vulnerability

contract RewardTimelock {
    mapping(address => uint256) balances;

    function executeRewardTransaction(uint256 amount) external {
        // Vulnerable code: updates state before external call
        balances[msg.sender] -= amount; // Update sender's balance first
        require(msg.sender.call{value: amount}("")); // External call last
    }
}

In this simplified example:An external attacker initiates the executeRewardTransaction function with a large amount value.Before the external call is made, the contract deducts the amount from the sender's balance using balances[msg.sender] -= amount.The attacker's fallback function is triggered by the external call, allowing them to re-enter the executeRewardTransaction function.Since the sender's balance has not yet been updated, the attacker's balance is not reduced when they re-enter the function.The attacker can repeatedly re-enter the function, draining funds from the contract without having their balance deducted.